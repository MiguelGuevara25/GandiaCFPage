import React from 'react';
/**
 * IPosition
 *
 * The position of a cell. x and y are its offsetX and offsetY position.
 * If a cell is to be removed or added the scale property will be added, 0 to 1
 */
interface IPosition {
    x: number;
    y: number;
    scale?: number;
}
/**
 * IPositions
 *
 * The collection of positions for each key
 */
interface IPositions {
    [key: string]: IPosition;
}
/**
 * StageType
 *
 * Determines what to render in the component
 */
export declare enum StageType {
    /**
     * STALE
     *
     * If the animation finishes the next stage will be STALE.
     * Render the cells in the wrapper statically positioned.
     */
    STALE = "STALE",
    /**
     * MEASURE
     *
     * If oldKeys.join() != nextKeys.join() then the next stage will be MEASURE.
     *
     * Render next cells in a hidden div and measure the position of each next cell.
     * Measure the height of the next hidden wrapper.
     *
     * Measure the position of each old cell.
     * Measure the height of the old wrapper.
     */
    MEASURE = "MEASURE",
    /**
     * COMMIT
     *
     * If stage is MEASURE then the next stage will be COMMIT.
     *
     * Render all unique cells from the old list of keys and the next list of keys.
     *
     * All cells are position absolute. The old cells should be css translated to their old position and scaled to 1.
     *
     * All new cells, i.e those keys in next keys which are not in old keys should be translated to their
     * next position, and scaled to 0.
     */
    COMMIT = "COMMIT",
    /**
     * ANIMATE
     *
     * If stage is COMMIT or ANIMATE_COMMIT then the next stage will be ANIMATE.
     *
     * For each cell that should be moved, i.e the intersection between old keys and new keys, update style.translate to the new position.
     *
     * For each cell that should be removed, i.e those in old keys not present in new keys, update style.scale to 0
     *
     * For each cell that should be added, i.e. those in new keys not present in old keys, update style.cale to 1
     */
    ANIMATE = "ANIMATE"
    /**
     * ANIMATE_MEASURE
     *
     * If stage is ANIMATE, and the keys are updated then the next stage will be ANIMATE_MEASURE.
     *
     * Render next cells in a hidden div and measure the position of each next cell.
     * Measure the height of the next hidden wrapper.
     *
     * The positions of the old cells should already be measured
     *
     * Render the same as in ANIMATE while rendering the measuring component.
     *
     */
    /**
     * ANIMATE_COMMIT
     *
     * If stage is ANIMATE_MEASURE then the next stage will be ANIMATE_COMMIT.
     *
     * Render all unique cells from the old lists of keys (notice plural on lists) and the next list of keys.
     * That is the the same as in ANIMATE.
     *
     * All cells which are now to be removed should be scaled to 0.
     *
     * All new cells, i.e those keys in next keys which are not in old keys should be translated to their
     * next position, and scaled to 0.
     */
}
/**
 * IFrame
 *
 * Holds information about the keys of rendered cells
 */
export interface IFrame {
    /**
     * The height of the container when all cells are rendered.
     */
    containerHeight: number | undefined;
    /**
     * The width of the container when all cells are rendered.
     */
    containerWidth: number | undefined;
    /**
     * The keys which should be rendered
     */
    keys: (string | number)[];
    /**
     * The positions of each cell
     */
    positions: IPositions;
    /**
     * A unique index used for debugging purposes to differentiate each IFrame
     */
    index: number;
    /**
     * If the frame has been measured
     */
    hasBeenMeasured: boolean;
    /**
     * a hash generated from the keys
     */
    hash: string;
}
/**
 * ICellStyle
 *
 * The styles passed to a renderCell
 */
export interface ICellStyle {
    position?: 'absolute';
    top?: string;
    left?: string;
    margin?: '0px';
    transition?: string;
    transform?: string;
}
/**
 * IWrapperStyle
 *
 * The styles passed to the renderWrapper
 */
export interface IWrapperStyle {
    position?: 'absolute' | 'relative';
    width?: number;
    height?: number;
    visibility?: 'hidden';
    zIndex?: -1;
}
/**
 * IProps
 *
 * The props accepted by ReactMixitup
 */
interface IProps {
    /**
     * keys should be a unique list of strings.
     */
    keys: (string | number)[];
    /**
     * MUST return a react node.
     *
     * The item.key corresponds to a key in the keys prop.
     * You should use the key to render the correct data in the cell.
     *
     * It MUST accept style and forward that to the returned component.
     * Style contains the transition styles.
     *
     * The ref MUST also be attached to the returned element so
     * ReactMixitup is able to measure the position of the cell.
     */
    renderCell: (key: string | number, style: ICellStyle, ref: React.Ref<any>, stage: StageType, frame: IFrame, activeFrame: boolean) => React.ReactNode | JSX.Element;
    /**
     * Optional, by default ReactMixitup will wrap all cells in a div.
     *
     * If provided renderWrapper MUST return a React node which accepts the provided style and ref.
     *
     * The ref is used to measure the height of the wrapping container.
     *
     * The style is used to update the height of the wrapping container.
     * By setting the transition: height style property on the wrapper the height can be animated.
     */
    renderWrapper?: (style: IWrapperStyle, ref: React.Ref<any>, cells: JSX.Element[], stage: StageType, frame: IFrame, activeFrame: boolean) => React.ReactNode | JSX.Element;
    /**
     * Disable the transition
     */
    disableTransition?: boolean;
    /**
     * If the wrapper should grow/shrink vertically or horizontally when adding and removing cells
     */
    dynamicDirection: 'horizontal' | 'vertical' | 'off';
    transitionDuration: number;
    reMeasureAllPreviousFramesOnNewKeys?: boolean;
    debugMeasure?: number;
}
/**
 * Creates a hash of the keys in order to determine if the keys are updated
 */
export declare function getKeysHash(keys: (string | number)[]): string;
export declare enum DOMLevel {
    ROOT = "ROOT",
    VISIBLE = "VISIBLE",
    WRAPPER = "WRAPPER",
    HIDDEN = "HIDDEN"
}
export declare const MixitupFragment: ({ children, level }: {
    children: React.ReactNode;
    level: DOMLevel;
}) => JSX.Element;
/**
 * MUST return a React node which accepts the provided style and ref.
 *
 * The ref is used to measure the height of the wrapping container.
 *
 * The style is used to update the height of the wrapping container.
 * By setting the transition: height style property on the wrapper the height can be animated.
 */
export declare type RenderWrapper = Exclude<IProps['renderWrapper'], undefined>;
/**
 * MUST return a react node.
 *
 * The item.key corresponds to a key in the keys prop.
 * You should use the key to render the correct data in the cell.
 *
 * It MUST accept style and forward that to the returned component.
 * Style contains the transition styles.
 *
 * The ref MUST also be attached to the returned element so
 * ReactMixitup is able to measure the position of the cell.
 */
export declare type RenderCell = Exclude<IProps['renderCell'], undefined>;
export declare const TEST_COMPONENT_UPDATE_DELAY = 100;
export declare const ReactMixitup: React.MemoExoticComponent<React.ForwardRefExoticComponent<IProps & React.RefAttributes<HTMLDivElement>>>;
export {};
