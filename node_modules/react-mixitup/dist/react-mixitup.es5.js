import React from 'react';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var createFrame = function (keys, index) {
    var nextHash = getKeysHash(keys);
    return {
        index: index,
        hash: nextHash,
        keys: keys,
        containerHeight: undefined,
        containerWidth: undefined,
        positions: {},
        hasBeenMeasured: false
    };
};

/**
 * StageType
 *
 * Determines what to render in the component
 */
var StageType;
(function (StageType) {
    /**
     * STALE
     *
     * If the animation finishes the next stage will be STALE.
     * Render the cells in the wrapper statically positioned.
     */
    StageType["STALE"] = "STALE";
    /**
     * MEASURE
     *
     * If oldKeys.join() != nextKeys.join() then the next stage will be MEASURE.
     *
     * Render next cells in a hidden div and measure the position of each next cell.
     * Measure the height of the next hidden wrapper.
     *
     * Measure the position of each old cell.
     * Measure the height of the old wrapper.
     */
    StageType["MEASURE"] = "MEASURE";
    /**
     * COMMIT
     *
     * If stage is MEASURE then the next stage will be COMMIT.
     *
     * Render all unique cells from the old list of keys and the next list of keys.
     *
     * All cells are position absolute. The old cells should be css translated to their old position and scaled to 1.
     *
     * All new cells, i.e those keys in next keys which are not in old keys should be translated to their
     * next position, and scaled to 0.
     */
    StageType["COMMIT"] = "COMMIT";
    /**
     * ANIMATE
     *
     * If stage is COMMIT or ANIMATE_COMMIT then the next stage will be ANIMATE.
     *
     * For each cell that should be moved, i.e the intersection between old keys and new keys, update style.translate to the new position.
     *
     * For each cell that should be removed, i.e those in old keys not present in new keys, update style.scale to 0
     *
     * For each cell that should be added, i.e. those in new keys not present in old keys, update style.cale to 1
     */
    StageType["ANIMATE"] = "ANIMATE";
    /**
     * ANIMATE_MEASURE
     *
     * If stage is ANIMATE, and the keys are updated then the next stage will be ANIMATE_MEASURE.
     *
     * Render next cells in a hidden div and measure the position of each next cell.
     * Measure the height of the next hidden wrapper.
     *
     * The positions of the old cells should already be measured
     *
     * Render the same as in ANIMATE while rendering the measuring component.
     *
     */
    // replaced by MEASURE where stage.whileAnimating = true;
    // ANIMATE_MEASURE = 'ANIMATE_MEASURE',
    /**
     * ANIMATE_COMMIT
     *
     * If stage is ANIMATE_MEASURE then the next stage will be ANIMATE_COMMIT.
     *
     * Render all unique cells from the old lists of keys (notice plural on lists) and the next list of keys.
     * That is the the same as in ANIMATE.
     *
     * All cells which are now to be removed should be scaled to 0.
     *
     * All new cells, i.e those keys in next keys which are not in old keys should be translated to their
     * next position, and scaled to 0.
     */
    // replaced by COMMIT where stage.whileAnimating = true;
    // ANIMATE_COMMIT = 'ANIMATE_COMMIT'
})(StageType || (StageType = {}));
/**
 * Creates a hash of the keys in order to determine if the keys are updated
 */
function getKeysHash(keys) {
    return keys.map(function (k) { return "" + (typeof k)[0] + k; }).join(',');
}
var DOMLevel;
(function (DOMLevel) {
    DOMLevel["ROOT"] = "ROOT";
    DOMLevel["VISIBLE"] = "VISIBLE";
    DOMLevel["WRAPPER"] = "WRAPPER";
    DOMLevel["HIDDEN"] = "HIDDEN";
})(DOMLevel || (DOMLevel = {}));
var MixitupFragment = function (_a) {
    var children = _a.children; _a.level;
    return React.createElement(React.Fragment, null, children);
};
/**
 * Default renderer
 */
var defaultRenderWrapper = function (style, ref, cells) {
    return (React.createElement("div", { style: style, ref: ref }, cells));
};
var TEST_COMPONENT_UPDATE_DELAY = 100;
var NotifyAboutRendered = function (_a) {
    var children = _a.children, frame = _a.frame;
    React.useLayoutEffect(function () {
        frame.hasBeenMeasured = true;
    }, [frame]);
    return React.createElement(React.Fragment, null, children);
};
var processEnv = function (name) {
    if (typeof process !== 'undefined' && process.env) {
        return process.env[name];
    }
};
var debug = function () {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        msg[_i] = arguments[_i];
    }
    if (processEnv('DEBUG:react-mixitup')) {
        console.log.apply(console, msg);
    }
    else if (typeof window !== 'undefined' && window.localStorage) {
        if (window.localStorage.getItem('DEBUG:react-mixitup')) {
            console.log.apply(console, msg);
        }
    }
};
var ReactMixitup = React.memo(React.forwardRef(function (props, outerBoundRef) {
    var keys = props.keys, renderCell = props.renderCell, _a = props.renderWrapper, renderWrapper = _a === void 0 ? defaultRenderWrapper : _a, disableTransitionProp = props.disableTransition, dynamicDirection = props.dynamicDirection, transitionDuration = props.transitionDuration;
    var disableTransition = !!disableTransitionProp || transitionDuration === 0 || false;
    if (!keys) {
        throw new Error('Invalid keys: keys must be provided');
    }
    if (new Set(keys).size !== keys.length) {
        throw new Error('Invalid keys: every key must be unique');
    }
    if (typeof transitionDuration !== 'number' || transitionDuration < 0) {
        throw new Error('Invalid transitionDuration: transition duration must be a number > 0');
    }
    if (!renderCell || typeof renderCell !== 'function') {
        throw new Error('Invalid renderCell: must be a function');
    }
    if (!renderWrapper || typeof renderWrapper !== 'function') {
        throw new Error('Invalid renderWrapper: must be a function');
    }
    if (props.debugMeasure && typeof props.debugMeasure !== 'number') {
        throw new Error('Invalid debugMeasure: must be a number');
    }
    var indexRef = React.useRef(0);
    var nextHash = getKeysHash(keys);
    var refs = React.useRef(undefined);
    if (!refs.current) {
        var frame = createFrame(keys, indexRef.current++);
        refs.current = {
            frames: [frame],
            persistedElement: null,
            hash: undefined,
            stage: { type: StageType.STALE, frame: frame }
        };
    }
    var _b = React.useState(0), _update = _b[1];
    var hasUnmounted = React.useRef(false);
    React.useEffect(function () { return function () {
        hasUnmounted.current = true;
    }; }, []);
    var update = function () {
        setTimeout(function () {
            if (!hasUnmounted.current) {
                _update(function (i) { return i + 1; });
            }
        }, processEnv('NODE_ENV') === 'test' ? TEST_COMPONENT_UPDATE_DELAY : 1);
    };
    function goToStale(frame) {
        debug('go to STALE');
        refs.current.stage = {
            type: StageType.STALE,
            frame: frame
        };
        // stale should always only have 1 frame
        refs.current.frames = [frame];
        update();
    }
    React.useEffect(function () {
        var goToStaleOrNext = function (cb) {
            if (!props.debugMeasure) {
                cb();
                return;
            }
            // only use case is when running with debugMeasure
            // then you can update many times while in commit
            // and end up at with the same keys as in the start
            var lastFrame = refs.current.frames[refs.current.frames.length - 1];
            if (refs.current.frames[0].hash === lastFrame.hash) {
                debug('due to last frame being the same as first key we go straight back to STALE');
                goToStale(lastFrame);
            }
            else {
                cb();
            }
        };
        var goToAnimate = function () {
            // from commit or measure
            goToStaleOrNext(function () {
                refs.current.stage = {
                    type: StageType.ANIMATE
                };
                if (processEnv('NODE_ENV') === 'test') {
                    setTimeout(function () {
                        update();
                    }, TEST_COMPONENT_UPDATE_DELAY);
                }
                else {
                    window.requestAnimationFrame(function () {
                        update();
                    });
                }
            });
        };
        var goToCommit = function (whileAnimating) {
            // from measure
            goToStaleOrNext(function () {
                refs.current.stage = {
                    type: StageType.COMMIT,
                    whileAnimating: whileAnimating
                };
                update();
            });
        };
        var maybeDelay = function (cb) {
            if (props.debugMeasure) {
                var t_1 = setTimeout(function () {
                    cb();
                }, props.debugMeasure);
                return function () {
                    clearTimeout(t_1);
                };
            }
            cb();
        };
        if (refs.current.stage.type === StageType.MEASURE) {
            if (dynamicDirection === 'off') {
                // skip COMMIT phase, go straight to ANIMATE
                return maybeDelay(function () { return goToAnimate(); });
            }
            var whileAnimating_1 = refs.current.stage.whileAnimating;
            return maybeDelay(function () { return goToCommit(whileAnimating_1); });
        }
        if (refs.current.stage.type === StageType.COMMIT) {
            goToAnimate();
        }
    });
    if (refs.current.hash === undefined) {
        // first render
        refs.current.hash = nextHash;
    }
    if (refs.current.hash !== nextHash) {
        refs.current.hash = nextHash;
        var frame = createFrame(keys, indexRef.current++);
        if (disableTransition) {
            refs.current.frames.splice(0, refs.current.frames.length, frame);
            refs.current.stage = {
                type: StageType.STALE,
                frame: frame
            };
        }
        else {
            refs.current.frames.push(frame);
            var whileAnimating = 'whileAnimating' in refs.current.stage
                ? refs.current.stage.whileAnimating
                : refs.current.stage.type === StageType.ANIMATE;
            refs.current.stage = {
                type: StageType.MEASURE,
                frameToMeasure: frame,
                whileAnimating: whileAnimating
            };
        }
    }
    var measureGridItems = function (frame, key, el) {
        var pos = {
            x: el.offsetLeft,
            y: el.offsetTop
        };
        frame.positions[key] = pos;
    };
    var wrapperMeasureContainerSize = function (frame, el) {
        if (!el) {
            return;
        }
        var h = el.offsetHeight;
        var w = el.offsetWidth;
        frame.containerHeight = h;
        frame.containerWidth = w;
    };
    var cells = function (_a) {
        var ref = _a.ref, style = _a.style, keys = _a.keys, stageType = _a.stageType, activeFrame = _a.activeFrame;
        var makeRef = function (key) {
            return function (el) {
                if (el) {
                    ref(key, el);
                }
            };
        };
        var cells = keys.map(function (_a) {
            var key = _a.key, frame = _a.frame;
            return (React.createElement(React.Fragment, { key: key }, renderCell(key, style(key), makeRef(key), stageType, frame, activeFrame)));
        });
        return cells;
    };
    var measureFrame = function (frame, activeFrame) { return (React.createElement(NotifyAboutRendered, { frame: frame }, renderWrapper(props.debugMeasure
        ? {
            position: 'absolute'
        }
        : {
            position: 'absolute',
            visibility: 'hidden',
            zIndex: -1
        }, function (el) {
        wrapperMeasureContainerSize(frame, el);
    }, cells({
        ref: function (key, el) {
            measureGridItems(frame, key, el);
        },
        keys: frame.keys.map(function (key) { return ({ key: key, frame: frame }); }),
        style: staleStyle,
        stageType: StageType.MEASURE,
        activeFrame: activeFrame
    }), StageType.MEASURE, frame, activeFrame))); };
    var onEndOfTransition = function () {
        var frame = refs.current.frames[refs.current.frames.length - 1];
        debug('end of transition');
        goToStale(frame);
    };
    React.useEffect(function () {
        if (refs.current.stage.type === StageType.ANIMATE) {
            debug('set timeout');
            var timeout_1 = setTimeout(function () {
                onEndOfTransition();
            }, transitionDuration);
            return function () {
                debug('clear timeout');
                clearTimeout(timeout_1);
            };
        }
    });
    var staleStyle = function () { return ({
        transition: '0s 0s all ease',
        transform: 'none'
    }); };
    debug('current stage', refs.current.stage.type);
    // BEGIN RENDER
    // The keys used on the React.Fragments are there to assist React in preseving the DOM tree nodes and
    // prevent unmounting of components which interupts animation
    // The hierarchies:
    // root-level > visible-level > wrapper-level > renderWrapper
    //      ↳     > hidden-level > [key] > wrapper-level > NotifyAboutRendered > renderWrapper
    /**
     * staleFrame
     *
     * Renders the cells without any modifications
     *
     * @param frame IFrame
     * @returns React.ReactNode | JSX.Element
     */
    var staleFrame = function (frame) { return (React.createElement(MixitupFragment, { key: DOMLevel.WRAPPER, level: DOMLevel.WRAPPER }, renderWrapper({}, function () { }, cells({
        ref: function () { },
        keys: frame.keys.map(function (key) { return ({ key: key, frame: frame }); }),
        style: staleStyle,
        stageType: StageType.STALE,
        activeFrame: true
    }), StageType.STALE, frame, true))); };
    // If transitions are disabled, always render the staleFrame node
    if (disableTransition) {
        return (React.createElement(MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            React.createElement(MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE }, staleFrame(refs.current.frames[refs.current.frames.length - 1]))));
    }
    /**
     * getKeyFrameParticipation
     *
     * returns the frame indices where a key is present
     *
     * @param frames IFrame[]
     * @param key string
     * @returns number[]
     */
    var getKeyFrameParticipation = function (frames, key) {
        var indexes = [];
        for (var i = frames.length - 1; i >= 0; i -= 1) {
            var frame = frames[i];
            if (frame.keys.includes(key)) {
                indexes.push(i);
            }
        }
        return indexes;
    };
    var animatedCellStyle = function (type, key, frames) {
        var z = 1;
        var indexes = getKeyFrameParticipation(frames, key);
        if (indexes.length === 0) {
            throw new Error('something went wrong in the lib');
        }
        var _a = frames[indexes[0]].positions[key], xTarget = _a.x, yTarget = _a.y;
        var _b = frames[indexes[indexes.length - 1]].positions[key], xSource = _b.x, ySource = _b.y;
        var style = {
            position: 'absolute',
            top: '0px',
            left: '0px',
            margin: '0px'
        };
        /* will be added */
        // Last frame has the key.
        // The key has not been added before.
        // Type is commit
        if (frames[frames.length - 1].keys.includes(key) &&
            indexes.length === 1 &&
            type === StageType.COMMIT) {
            // scale from 0 -> 1 when going from COMMIT -> ANIMATE
            z = 0;
        }
        /* will be removed */
        if (!frames[frames.length - 1].keys.includes(key)) {
            // simply remove
            z = 0;
        }
        var xDiff = xTarget - xSource;
        var yDiff = yTarget - ySource;
        style.left = xSource + 'px';
        style.top = ySource + 'px';
        if (type === StageType.COMMIT) {
            style.transform = "translate3d(" + [0, 0, 0].join('px,') + "px) scale(" + z + ")";
        }
        else {
            style.transform = "translate3d(" + [xDiff, yDiff, 0].join('px,') + "px) scale(" + z + ")";
        }
        return style;
    };
    var getAllUniqueKeysForFrames = function (frames) {
        var keys = [];
        var keysSet = new Set();
        frames.forEach(function (frame) {
            frame.keys.forEach(function (key) {
                if (keysSet.has(key)) {
                    return;
                }
                keysSet.add(key);
                keys.push({ frame: frame, key: key });
            });
        });
        return keys;
    };
    /**
     * animatingFrame
     *
     * Returns the nodes which renders while animating.
     * Translate all elements to ther corresponding static location in the latest frame
     *
     * @param frames IFrame[]
     * @returns JSX.Element
     */
    var animatingFrame = function (frames) {
        var lastFrame = frames[frames.length - 1];
        var height = lastFrame.containerHeight;
        var width = lastFrame.containerWidth;
        var styles = {
            position: 'relative'
        };
        if (dynamicDirection === 'horizontal') {
            styles.width = width;
        }
        else if (dynamicDirection === 'vertical') {
            styles.height = height;
        }
        var keys = getAllUniqueKeysForFrames(frames);
        return (React.createElement(MixitupFragment, { key: DOMLevel.WRAPPER, level: DOMLevel.WRAPPER }, renderWrapper(__assign({}, styles), function () { }, cells({
            ref: function (key, el) { },
            keys: keys,
            style: function (key) {
                return animatedCellStyle(StageType.ANIMATE, key, frames);
            },
            stageType: StageType.ANIMATE,
            activeFrame: true
        }), StageType.ANIMATE, lastFrame, true)));
    };
    // When animating render the animatingFrame
    if (refs.current.stage.type === StageType.ANIMATE) {
        return (React.createElement(MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            React.createElement(MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE }, animatingFrame(refs.current.frames))));
    }
    // Commit will translate all elements to their corresponding static location of the previous frame.
    if (refs.current.stage.type === StageType.COMMIT) {
        var stage = refs.current.stage;
        var sizeFrame = refs.current.frames[refs.current.frames.length - 2];
        if (stage.whileAnimating) {
            sizeFrame = refs.current.frames[refs.current.frames.length - 1];
        }
        var height = sizeFrame.containerHeight;
        var width = sizeFrame.containerWidth;
        var styles = {
            position: 'relative'
        };
        if (dynamicDirection === 'horizontal') {
            styles.width = width;
        }
        else if (dynamicDirection === 'vertical') {
            styles.height = height;
        }
        var keys_1 = getAllUniqueKeysForFrames(refs.current.frames);
        return (React.createElement(MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            React.createElement(MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE },
                React.createElement(MixitupFragment, { key: DOMLevel.WRAPPER, level: DOMLevel.WRAPPER }, renderWrapper(__assign({}, styles), function () { }, cells({
                    ref: function (key, el) { },
                    keys: keys_1,
                    style: function (key) {
                        return animatedCellStyle(StageType.COMMIT, key, refs.current.frames);
                    },
                    stageType: StageType.COMMIT,
                    activeFrame: true
                }), StageType.COMMIT, sizeFrame, true)))));
    }
    // Measure
    if (refs.current.stage.type === StageType.MEASURE) {
        var len_1 = refs.current.frames.length;
        refs.current.frames[len_1 - 1];
        var measureFrames_1 = refs.current.frames;
        if (!props.reMeasureAllPreviousFramesOnNewKeys) {
            measureFrames_1 = [];
            refs.current.frames.forEach(function (frame, index) {
                if (!frame.hasBeenMeasured) {
                    measureFrames_1.push(frame);
                }
                else if (index >= len_1 - 2) {
                    // push the last 2 frames
                    measureFrames_1.push(frame);
                }
            });
        }
        return (React.createElement(MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            React.createElement(MixitupFragment, { key: DOMLevel.HIDDEN, level: DOMLevel.HIDDEN }, measureFrames_1.map(function (frame, index) {
                return (React.createElement(React.Fragment, { key: frame.index }, measureFrame(frame, index === measureFrames_1.length - 1)));
            })),
            React.createElement(MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE }, refs.current.stage.whileAnimating
                ? animatingFrame(refs.current.frames.filter(function (frame) { return frame.hasBeenMeasured; }))
                : staleFrame(refs.current.frames[0]))));
    }
    // If stage is stale render the stale frame
    if (refs.current.stage.type === StageType.STALE) {
        return (React.createElement(MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            React.createElement(MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE }, staleFrame(refs.current.stage.frame))));
    }
    return null;
}));

export { DOMLevel, MixitupFragment, ReactMixitup, StageType, TEST_COMPONENT_UPDATE_DELAY, getKeysHash };
//# sourceMappingURL=react-mixitup.es5.js.map
