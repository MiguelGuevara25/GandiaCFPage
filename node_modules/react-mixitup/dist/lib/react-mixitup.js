"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactMixitup = exports.TEST_COMPONENT_UPDATE_DELAY = exports.MixitupFragment = exports.DOMLevel = exports.getKeysHash = exports.StageType = void 0;
var react_1 = require("react");
var utils_1 = require("./utils");
/**
 * StageType
 *
 * Determines what to render in the component
 */
var StageType;
(function (StageType) {
    /**
     * STALE
     *
     * If the animation finishes the next stage will be STALE.
     * Render the cells in the wrapper statically positioned.
     */
    StageType["STALE"] = "STALE";
    /**
     * MEASURE
     *
     * If oldKeys.join() != nextKeys.join() then the next stage will be MEASURE.
     *
     * Render next cells in a hidden div and measure the position of each next cell.
     * Measure the height of the next hidden wrapper.
     *
     * Measure the position of each old cell.
     * Measure the height of the old wrapper.
     */
    StageType["MEASURE"] = "MEASURE";
    /**
     * COMMIT
     *
     * If stage is MEASURE then the next stage will be COMMIT.
     *
     * Render all unique cells from the old list of keys and the next list of keys.
     *
     * All cells are position absolute. The old cells should be css translated to their old position and scaled to 1.
     *
     * All new cells, i.e those keys in next keys which are not in old keys should be translated to their
     * next position, and scaled to 0.
     */
    StageType["COMMIT"] = "COMMIT";
    /**
     * ANIMATE
     *
     * If stage is COMMIT or ANIMATE_COMMIT then the next stage will be ANIMATE.
     *
     * For each cell that should be moved, i.e the intersection between old keys and new keys, update style.translate to the new position.
     *
     * For each cell that should be removed, i.e those in old keys not present in new keys, update style.scale to 0
     *
     * For each cell that should be added, i.e. those in new keys not present in old keys, update style.cale to 1
     */
    StageType["ANIMATE"] = "ANIMATE";
    /**
     * ANIMATE_MEASURE
     *
     * If stage is ANIMATE, and the keys are updated then the next stage will be ANIMATE_MEASURE.
     *
     * Render next cells in a hidden div and measure the position of each next cell.
     * Measure the height of the next hidden wrapper.
     *
     * The positions of the old cells should already be measured
     *
     * Render the same as in ANIMATE while rendering the measuring component.
     *
     */
    // replaced by MEASURE where stage.whileAnimating = true;
    // ANIMATE_MEASURE = 'ANIMATE_MEASURE',
    /**
     * ANIMATE_COMMIT
     *
     * If stage is ANIMATE_MEASURE then the next stage will be ANIMATE_COMMIT.
     *
     * Render all unique cells from the old lists of keys (notice plural on lists) and the next list of keys.
     * That is the the same as in ANIMATE.
     *
     * All cells which are now to be removed should be scaled to 0.
     *
     * All new cells, i.e those keys in next keys which are not in old keys should be translated to their
     * next position, and scaled to 0.
     */
    // replaced by COMMIT where stage.whileAnimating = true;
    // ANIMATE_COMMIT = 'ANIMATE_COMMIT'
})(StageType = exports.StageType || (exports.StageType = {}));
/**
 * Creates a hash of the keys in order to determine if the keys are updated
 */
function getKeysHash(keys) {
    return keys.map(function (k) { return "" + (typeof k)[0] + k; }).join(',');
}
exports.getKeysHash = getKeysHash;
var DOMLevel;
(function (DOMLevel) {
    DOMLevel["ROOT"] = "ROOT";
    DOMLevel["VISIBLE"] = "VISIBLE";
    DOMLevel["WRAPPER"] = "WRAPPER";
    DOMLevel["HIDDEN"] = "HIDDEN";
})(DOMLevel = exports.DOMLevel || (exports.DOMLevel = {}));
var MixitupFragment = function (_a) {
    var children = _a.children, level = _a.level;
    return react_1.default.createElement(react_1.default.Fragment, null, children);
};
exports.MixitupFragment = MixitupFragment;
/**
 * Default renderer
 */
var defaultRenderWrapper = function (style, ref, cells) {
    return (react_1.default.createElement("div", { style: style, ref: ref }, cells));
};
exports.TEST_COMPONENT_UPDATE_DELAY = 100;
var NotifyAboutRendered = function (_a) {
    var children = _a.children, frame = _a.frame;
    react_1.default.useLayoutEffect(function () {
        frame.hasBeenMeasured = true;
    }, [frame]);
    return react_1.default.createElement(react_1.default.Fragment, null, children);
};
var processEnv = function (name) {
    if (typeof process !== 'undefined' && process.env) {
        return process.env[name];
    }
};
var debug = function () {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        msg[_i] = arguments[_i];
    }
    if (processEnv('DEBUG:react-mixitup')) {
        console.log.apply(console, msg);
    }
    else if (typeof window !== 'undefined' && window.localStorage) {
        if (window.localStorage.getItem('DEBUG:react-mixitup')) {
            console.log.apply(console, msg);
        }
    }
};
exports.ReactMixitup = react_1.default.memo(react_1.default.forwardRef(function (props, outerBoundRef) {
    var keys = props.keys, renderCell = props.renderCell, _a = props.renderWrapper, renderWrapper = _a === void 0 ? defaultRenderWrapper : _a, disableTransitionProp = props.disableTransition, dynamicDirection = props.dynamicDirection, transitionDuration = props.transitionDuration;
    var disableTransition = !!disableTransitionProp || transitionDuration === 0 || false;
    if (!keys) {
        throw new Error('Invalid keys: keys must be provided');
    }
    if (new Set(keys).size !== keys.length) {
        throw new Error('Invalid keys: every key must be unique');
    }
    if (typeof transitionDuration !== 'number' || transitionDuration < 0) {
        throw new Error('Invalid transitionDuration: transition duration must be a number > 0');
    }
    if (!renderCell || typeof renderCell !== 'function') {
        throw new Error('Invalid renderCell: must be a function');
    }
    if (!renderWrapper || typeof renderWrapper !== 'function') {
        throw new Error('Invalid renderWrapper: must be a function');
    }
    if (props.debugMeasure && typeof props.debugMeasure !== 'number') {
        throw new Error('Invalid debugMeasure: must be a number');
    }
    var indexRef = react_1.default.useRef(0);
    var nextHash = getKeysHash(keys);
    var refs = react_1.default.useRef(undefined);
    if (!refs.current) {
        var frame = (0, utils_1.createFrame)(keys, indexRef.current++);
        refs.current = {
            frames: [frame],
            persistedElement: null,
            hash: undefined,
            stage: { type: StageType.STALE, frame: frame }
        };
    }
    var _b = react_1.default.useState(0), _update = _b[1];
    var hasUnmounted = react_1.default.useRef(false);
    react_1.default.useEffect(function () { return function () {
        hasUnmounted.current = true;
    }; }, []);
    var update = function () {
        setTimeout(function () {
            if (!hasUnmounted.current) {
                _update(function (i) { return i + 1; });
            }
        }, processEnv('NODE_ENV') === 'test' ? exports.TEST_COMPONENT_UPDATE_DELAY : 1);
    };
    function goToStale(frame) {
        debug('go to STALE');
        refs.current.stage = {
            type: StageType.STALE,
            frame: frame
        };
        // stale should always only have 1 frame
        refs.current.frames = [frame];
        update();
    }
    react_1.default.useEffect(function () {
        var goToStaleOrNext = function (cb) {
            if (!props.debugMeasure) {
                cb();
                return;
            }
            // only use case is when running with debugMeasure
            // then you can update many times while in commit
            // and end up at with the same keys as in the start
            var lastFrame = refs.current.frames[refs.current.frames.length - 1];
            if (refs.current.frames[0].hash === lastFrame.hash) {
                debug('due to last frame being the same as first key we go straight back to STALE');
                goToStale(lastFrame);
            }
            else {
                cb();
            }
        };
        var goToAnimate = function () {
            // from commit or measure
            goToStaleOrNext(function () {
                refs.current.stage = {
                    type: StageType.ANIMATE
                };
                if (processEnv('NODE_ENV') === 'test') {
                    setTimeout(function () {
                        update();
                    }, exports.TEST_COMPONENT_UPDATE_DELAY);
                }
                else {
                    window.requestAnimationFrame(function () {
                        update();
                    });
                }
            });
        };
        var goToCommit = function (whileAnimating) {
            // from measure
            goToStaleOrNext(function () {
                refs.current.stage = {
                    type: StageType.COMMIT,
                    whileAnimating: whileAnimating
                };
                update();
            });
        };
        var maybeDelay = function (cb) {
            if (props.debugMeasure) {
                var t_1 = setTimeout(function () {
                    cb();
                }, props.debugMeasure);
                return function () {
                    clearTimeout(t_1);
                };
            }
            cb();
        };
        if (refs.current.stage.type === StageType.MEASURE) {
            if (dynamicDirection === 'off') {
                // skip COMMIT phase, go straight to ANIMATE
                return maybeDelay(function () { return goToAnimate(); });
            }
            var whileAnimating_1 = refs.current.stage.whileAnimating;
            return maybeDelay(function () { return goToCommit(whileAnimating_1); });
        }
        if (refs.current.stage.type === StageType.COMMIT) {
            goToAnimate();
        }
    });
    if (refs.current.hash === undefined) {
        // first render
        refs.current.hash = nextHash;
    }
    if (refs.current.hash !== nextHash) {
        refs.current.hash = nextHash;
        var frame = (0, utils_1.createFrame)(keys, indexRef.current++);
        if (disableTransition) {
            refs.current.frames.splice(0, refs.current.frames.length, frame);
            refs.current.stage = {
                type: StageType.STALE,
                frame: frame
            };
        }
        else {
            refs.current.frames.push(frame);
            var whileAnimating = 'whileAnimating' in refs.current.stage
                ? refs.current.stage.whileAnimating
                : refs.current.stage.type === StageType.ANIMATE;
            refs.current.stage = {
                type: StageType.MEASURE,
                frameToMeasure: frame,
                whileAnimating: whileAnimating
            };
        }
    }
    var measureGridItems = function (frame, key, el) {
        var pos = {
            x: el.offsetLeft,
            y: el.offsetTop
        };
        frame.positions[key] = pos;
    };
    var wrapperMeasureContainerSize = function (frame, el) {
        if (!el) {
            return;
        }
        var h = el.offsetHeight;
        var w = el.offsetWidth;
        frame.containerHeight = h;
        frame.containerWidth = w;
    };
    var cells = function (_a) {
        var ref = _a.ref, style = _a.style, keys = _a.keys, stageType = _a.stageType, activeFrame = _a.activeFrame;
        var makeRef = function (key) {
            return function (el) {
                if (el) {
                    ref(key, el);
                }
            };
        };
        var cells = keys.map(function (_a) {
            var key = _a.key, frame = _a.frame;
            return (react_1.default.createElement(react_1.default.Fragment, { key: key }, renderCell(key, style(key), makeRef(key), stageType, frame, activeFrame)));
        });
        return cells;
    };
    var measureFrame = function (frame, activeFrame) { return (react_1.default.createElement(NotifyAboutRendered, { frame: frame }, renderWrapper(props.debugMeasure
        ? {
            position: 'absolute'
        }
        : {
            position: 'absolute',
            visibility: 'hidden',
            zIndex: -1
        }, function (el) {
        wrapperMeasureContainerSize(frame, el);
    }, cells({
        ref: function (key, el) {
            measureGridItems(frame, key, el);
        },
        keys: frame.keys.map(function (key) { return ({ key: key, frame: frame }); }),
        style: staleStyle,
        stageType: StageType.MEASURE,
        activeFrame: activeFrame
    }), StageType.MEASURE, frame, activeFrame))); };
    var onEndOfTransition = function () {
        var frame = refs.current.frames[refs.current.frames.length - 1];
        debug('end of transition');
        goToStale(frame);
    };
    react_1.default.useEffect(function () {
        if (refs.current.stage.type === StageType.ANIMATE) {
            debug('set timeout');
            var timeout_1 = setTimeout(function () {
                onEndOfTransition();
            }, transitionDuration);
            return function () {
                debug('clear timeout');
                clearTimeout(timeout_1);
            };
        }
    });
    var staleStyle = function () { return ({
        transition: '0s 0s all ease',
        transform: 'none'
    }); };
    debug('current stage', refs.current.stage.type);
    // BEGIN RENDER
    // The keys used on the React.Fragments are there to assist React in preseving the DOM tree nodes and
    // prevent unmounting of components which interupts animation
    // The hierarchies:
    // root-level > visible-level > wrapper-level > renderWrapper
    //      ↳     > hidden-level > [key] > wrapper-level > NotifyAboutRendered > renderWrapper
    /**
     * staleFrame
     *
     * Renders the cells without any modifications
     *
     * @param frame IFrame
     * @returns React.ReactNode | JSX.Element
     */
    var staleFrame = function (frame) { return (react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.WRAPPER, level: DOMLevel.WRAPPER }, renderWrapper({}, function () { }, cells({
        ref: function () { },
        keys: frame.keys.map(function (key) { return ({ key: key, frame: frame }); }),
        style: staleStyle,
        stageType: StageType.STALE,
        activeFrame: true
    }), StageType.STALE, frame, true))); };
    // If transitions are disabled, always render the staleFrame node
    if (disableTransition) {
        return (react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE }, staleFrame(refs.current.frames[refs.current.frames.length - 1]))));
    }
    /**
     * getKeyFrameParticipation
     *
     * returns the frame indices where a key is present
     *
     * @param frames IFrame[]
     * @param key string
     * @returns number[]
     */
    var getKeyFrameParticipation = function (frames, key) {
        var indexes = [];
        for (var i = frames.length - 1; i >= 0; i -= 1) {
            var frame = frames[i];
            if (frame.keys.includes(key)) {
                indexes.push(i);
            }
        }
        return indexes;
    };
    var animatedCellStyle = function (type, key, frames) {
        var z = 1;
        var indexes = getKeyFrameParticipation(frames, key);
        if (indexes.length === 0) {
            throw new Error('something went wrong in the lib');
        }
        var _a = frames[indexes[0]].positions[key], xTarget = _a.x, yTarget = _a.y;
        var _b = frames[indexes[indexes.length - 1]].positions[key], xSource = _b.x, ySource = _b.y;
        var style = {
            position: 'absolute',
            top: '0px',
            left: '0px',
            margin: '0px'
        };
        /* will be added */
        // Last frame has the key.
        // The key has not been added before.
        // Type is commit
        if (frames[frames.length - 1].keys.includes(key) &&
            indexes.length === 1 &&
            type === StageType.COMMIT) {
            // scale from 0 -> 1 when going from COMMIT -> ANIMATE
            z = 0;
        }
        /* will be removed */
        if (!frames[frames.length - 1].keys.includes(key)) {
            // simply remove
            z = 0;
        }
        var xDiff = xTarget - xSource;
        var yDiff = yTarget - ySource;
        style.left = xSource + 'px';
        style.top = ySource + 'px';
        if (type === StageType.COMMIT) {
            style.transform = "translate3d(" + [0, 0, 0].join('px,') + "px) scale(" + z + ")";
        }
        else {
            style.transform = "translate3d(" + [xDiff, yDiff, 0].join('px,') + "px) scale(" + z + ")";
        }
        return style;
    };
    var getAllUniqueKeysForFrames = function (frames) {
        var keys = [];
        var keysSet = new Set();
        frames.forEach(function (frame) {
            frame.keys.forEach(function (key) {
                if (keysSet.has(key)) {
                    return;
                }
                keysSet.add(key);
                keys.push({ frame: frame, key: key });
            });
        });
        return keys;
    };
    /**
     * animatingFrame
     *
     * Returns the nodes which renders while animating.
     * Translate all elements to ther corresponding static location in the latest frame
     *
     * @param frames IFrame[]
     * @returns JSX.Element
     */
    var animatingFrame = function (frames) {
        var lastFrame = frames[frames.length - 1];
        var height = lastFrame.containerHeight;
        var width = lastFrame.containerWidth;
        var styles = {
            position: 'relative'
        };
        if (dynamicDirection === 'horizontal') {
            styles.width = width;
        }
        else if (dynamicDirection === 'vertical') {
            styles.height = height;
        }
        var keys = getAllUniqueKeysForFrames(frames);
        return (react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.WRAPPER, level: DOMLevel.WRAPPER }, renderWrapper(__assign({}, styles), function () { }, cells({
            ref: function (key, el) { },
            keys: keys,
            style: function (key) {
                return animatedCellStyle(StageType.ANIMATE, key, frames);
            },
            stageType: StageType.ANIMATE,
            activeFrame: true
        }), StageType.ANIMATE, lastFrame, true)));
    };
    // When animating render the animatingFrame
    if (refs.current.stage.type === StageType.ANIMATE) {
        return (react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE }, animatingFrame(refs.current.frames))));
    }
    // Commit will translate all elements to their corresponding static location of the previous frame.
    if (refs.current.stage.type === StageType.COMMIT) {
        var stage = refs.current.stage;
        var sizeFrame = refs.current.frames[refs.current.frames.length - 2];
        if (stage.whileAnimating) {
            sizeFrame = refs.current.frames[refs.current.frames.length - 1];
        }
        var height = sizeFrame.containerHeight;
        var width = sizeFrame.containerWidth;
        var styles = {
            position: 'relative'
        };
        if (dynamicDirection === 'horizontal') {
            styles.width = width;
        }
        else if (dynamicDirection === 'vertical') {
            styles.height = height;
        }
        var keys_1 = getAllUniqueKeysForFrames(refs.current.frames);
        return (react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE },
                react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.WRAPPER, level: DOMLevel.WRAPPER }, renderWrapper(__assign({}, styles), function () { }, cells({
                    ref: function (key, el) { },
                    keys: keys_1,
                    style: function (key) {
                        return animatedCellStyle(StageType.COMMIT, key, refs.current.frames);
                    },
                    stageType: StageType.COMMIT,
                    activeFrame: true
                }), StageType.COMMIT, sizeFrame, true)))));
    }
    // Measure
    if (refs.current.stage.type === StageType.MEASURE) {
        var len_1 = refs.current.frames.length;
        var lastFrame = refs.current.frames[len_1 - 1];
        var measureFrames_1 = refs.current.frames;
        if (!props.reMeasureAllPreviousFramesOnNewKeys) {
            measureFrames_1 = [];
            refs.current.frames.forEach(function (frame, index) {
                if (!frame.hasBeenMeasured) {
                    measureFrames_1.push(frame);
                }
                else if (index >= len_1 - 2) {
                    // push the last 2 frames
                    measureFrames_1.push(frame);
                }
            });
        }
        return (react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.HIDDEN, level: DOMLevel.HIDDEN }, measureFrames_1.map(function (frame, index) {
                return (react_1.default.createElement(react_1.default.Fragment, { key: frame.index }, measureFrame(frame, index === measureFrames_1.length - 1)));
            })),
            react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE }, refs.current.stage.whileAnimating
                ? animatingFrame(refs.current.frames.filter(function (frame) { return frame.hasBeenMeasured; }))
                : staleFrame(refs.current.frames[0]))));
    }
    // If stage is stale render the stale frame
    if (refs.current.stage.type === StageType.STALE) {
        return (react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.ROOT, level: DOMLevel.ROOT },
            react_1.default.createElement(exports.MixitupFragment, { key: DOMLevel.VISIBLE, level: DOMLevel.VISIBLE }, staleFrame(refs.current.stage.frame))));
    }
    return null;
}));
//# sourceMappingURL=react-mixitup.js.map